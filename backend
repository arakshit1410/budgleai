// =============================================
// FILE: package.json
// =============================================
{
  "name": "budgle-backend",
  "version": "1.0.0",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "seed": "node src/seed.js"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.3.1",
    "morgan": "^1.10.0",
    "axios": "^1.4.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}

// =============================================
// FILE: docker-compose.yml
// =============================================
version: '3.8'
services:
  app:
    build: .
    ports:
      - "4000:4000"
    env_file:
      - .env
    depends_on:
      - mongo
  mongo:
    image: mongo:6.0
    restart: always
    volumes:
      - mongo-data:/data/db
volumes:
  mongo-data:

// =============================================
// FILE: Dockerfile
// =============================================
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY src/ ./src/

EXPOSE 4000

CMD ["npm", "start"]

// =============================================
// FILE: .env.example
// =============================================
NODE_ENV=development
PORT=4000
MONGO_URI=mongodb://mongo:27017/budgle
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production

// =============================================
// FILE: src/index.js
// =============================================
const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const mongoose = require('mongoose');
require('dotenv').config();

const authRoutes = require('./routes/auth');
const transactionRoutes = require('./routes/transactions');
const goalRoutes = require('./routes/goals');
const aiRoutes = require('./routes/ai');
const blockchainRoutes = require('./routes/blockchain');
const userRoutes = require('./routes/users');
const alertRoutes = require('./routes/alerts');

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(morgan('combined'));

// Connect to MongoDB
mongoose.connect(process.env.MONGO_URI || 'mongodb://mongo:27017/budgle', {
  useNewUrlParser: true,
  useUnifiedTopology: true
});

const db = mongoose.connection;
db.on('error', console.error.bind(console, 'MongoDB connection error:'));
db.once('open', () => {
  console.log('üçÉ Connected to MongoDB');
});

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/transactions', transactionRoutes);
app.use('/api/goals', goalRoutes);
app.use('/api/ai', aiRoutes);
app.use('/api/blockchain', blockchainRoutes);
app.use('/api/users', userRoutes);
app.use('/api/alerts', alertRoutes);

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'üöÄ BUDGLE Backend is running',
    timestamp: new Date().toISOString(),
    database: db.readyState === 1 ? 'Connected' : 'Disconnected',
    features: {
      ai: 'Active',
      blockchain: 'Active',
      fraud_detection: 'Active',
      karma_system: 'Active'
    }
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ 
    message: 'Something went wrong!', 
    error: process.env.NODE_ENV === 'development' ? err.message : 'Internal Server Error' 
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ message: 'Route not found' });
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
  console.log(`üöÄ BUDGLE Backend running on port ${PORT}`);
  console.log(`üí∞ AI + Blockchain Finance API Ready`);
  console.log(`üåê Health check: http://localhost:${PORT}/health`);
});

// =============================================
// FILE: src/models/User.js
// =============================================
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  fullName: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  mobile: {
    type: String,
    required: true,
    trim: true
  },
  password: {
    type: String,
    required: true,
    minlength: 8
  },
  balance: {
    type: Number,
    default: 0
  },
  totalIncome: {
    type: Number,
    default: 0
  },
  totalExpenses: {
    type: Number,
    default: 0
  },
  karmaTokens: {
    type: Number,
    default: 100
  },
  blockchainAddress: {
    type: String,
    unique: true
  },
  aiPreferences: {
    autoCategorize: { type: Boolean, default: true },
    fraudDetection: { type: Boolean, default: true },
    smartAlerts: { type: Boolean, default: true }
  },
  settings: {
    notifications: { type: Boolean, default: true },
    currency: { type: String, default: 'INR' }
  }
}, {
  timestamps: true
});

userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});

userSchema.methods.comparePassword = async function(password) {
  return await bcrypt.compare(password, this.password);
};

module.exports = mongoose.model('User', userSchema);

// =============================================
// FILE: src/models/Transaction.js
// =============================================
const mongoose = require('mongoose');

const transactionSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  title: {
    type: String,
    required: true
  },
  amount: {
    type: Number,
    required: true
  },
  category: {
    type: String,
    required: true,
    enum: ['food', 'transport', 'shopping', 'entertainment', 'health', 'utilities', 'education', 'income', 'other']
  },
  type: {
    type: String,
    required: true,
    enum: ['income', 'expense']
  },
  date: {
    type: Date,
    required: true
  },
  note: {
    type: String,
    trim: true
  },
  blockchainHash: {
    type: String,
    required: true
  },
  aiCategorized: {
    type: Boolean,
    default: false
  },
  aiConfidence: {
    type: Number,
    min: 0,
    max: 1
  },
  fraudCheck: {
    passed: { type: Boolean, default: true },
    score: { type: Number, default: 0 },
    reason: { type: String }
  }
}, {
  timestamps: true
});

module.exports = mongoose.model('Transaction', transactionSchema);

// =============================================
// FILE: src/models/Goal.js
// =============================================
const mongoose = require('mongoose');

const goalSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: {
    type: String,
    required: true
  },
  targetAmount: {
    type: Number,
    required: true
  },
  currentAmount: {
    type: Number,
    default: 0
  },
  frequency: {
    type: String,
    enum: ['daily', 'weekly', 'monthly', 'yearly'],
    default: 'monthly'
  },
  targetDate: {
    type: Date
  },
  status: {
    type: String,
    enum: ['active', 'completed', 'paused'],
    default: 'active'
  },
  icon: {
    type: String,
    default: 'üéØ'
  },
  blockchainHash: {
    type: String
  },
  aiOptimized: {
    suggestedAmount: { type: Number },
    optimizedDate: { type: Date },
    confidence: { type: Number }
  }
}, {
  timestamps: true
});

goalSchema.virtual('progress').get(function() {
  return Math.round((this.currentAmount / this.targetAmount) * 100);
});

goalSchema.set('toJSON', { virtuals: true });

module.exports = mongoose.model('Goal', goalSchema);

// =============================================
// FILE: src/models/Alert.js
// =============================================
const mongoose = require('mongoose');

const alertSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  type: {
    type: String,
    enum: ['normal', 'warning', 'danger', 'info'],
    required: true
  },
  category: {
    type: String,
    enum: ['fraud', 'spending', 'goal', 'system', 'ai', 'blockchain'],
    required: true
  },
  title: {
    type: String,
    required: true
  },
  message: {
    type: String,
    required: true
  },
  read: {
    type: Boolean,
    default: false
  },
  actionable: {
    type: Boolean,
    default: false
  },
  metadata: {
    transactionId: { type: mongoose.Schema.Types.ObjectId },
    amount: { type: Number },
    blockchainHash: { type: String }
  }
}, {
  timestamps: true
});

module.exports = mongoose.model('Alert', alertSchema);

// =============================================
// FILE: src/routes/auth.js
// =============================================
const express = require('express');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const { generateBlockchainAddress } = require('../utils/blockchain');

const router = express.Router();

router.post('/register', async (req, res) => {
  try {
    const { fullName, email, mobile, password } = req.body;

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const blockchainAddress = generateBlockchainAddress(email);

    const user = new User({
      fullName,
      email,
      mobile,
      password,
      blockchainAddress,
      karmaTokens: 100,
      balance: 26500,
      totalIncome: 45000,
      totalExpenses: 18500
    });

    await user.save();

    const token = jwt.sign(
      { userId: user._id },
      process.env.JWT_SECRET || 'budgle-secret-key',
      { expiresIn: '30d' }
    );

    res.status(201).json({
      message: 'User created successfully',
      token,
      user: {
        id: user._id,
        fullName: user.fullName,
        email: user.email,
        mobile: user.mobile,
        balance: user.balance,
        totalIncome: user.totalIncome,
        totalExpenses: user.totalExpenses,
        karmaTokens: user.karmaTokens,
        blockchainAddress: user.blockchainAddress
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ message: 'Registration failed', error: error.message });
  }
});

router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { userId: user._id },
      process.env.JWT_SECRET || 'budgle-secret-key',
      { expiresIn: '30d' }
    );

    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user._id,
        fullName: user.fullName,
        email: user.email,
        mobile: user.mobile,
        balance: user.balance,
        totalIncome: user.totalIncome,
        totalExpenses: user.totalExpenses,
        karmaTokens: user.karmaTokens,
        blockchainAddress: user.blockchainAddress
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Login failed', error: error.message });
  }
});

module.exports = router;

// =============================================
// FILE: src/routes/transactions.js
// =============================================
const express = require('express');
const Transaction = require('../models/Transaction');
const User = require('../models/User');
const { authenticateToken } = require('../middleware/auth');
const { categorizeTransaction, detectFraud } = require('../utils/ai');
const { generateTransactionHash } = require('../utils/blockchain');

const router = express.Router();

router.get('/', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 20, type, category } = req.query;
    
    const query = { userId: req.user.userId };
    if (type) query.type = type;
    if (category) query.category = category;

    const transactions = await Transaction.find(query)
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await Transaction.countDocuments(query);

    res.json({
      transactions,
      totalPages: Math.ceil(total / limit),
      currentPage: page,
      total
    });
  } catch (error) {
    res.status(500).json({ message: 'Failed to fetch transactions', error: error.message });
  }
});

router.post('/', authenticateToken, async (req, res) => {
  try {
    const { title, amount, category, type, date, note } = req.body;

    const aiResult = categorizeTransaction(title, note);
    const fraudCheck = detectFraud(title, amount, note);
    
    if (fraudCheck.isFraud) {
      return res.status(400).json({
        message: 'Transaction blocked for security',
        reason: fraudCheck.reason,
        confidence: fraudCheck.confidence
      });
    }

    const blockchainHash = generateTransactionHash({
      userId: req.user.userId,
      title,
      amount,
      category: aiResult.category,
      date
    });

    const transaction = new Transaction({
      userId: req.user.userId,
      title,
      amount: type === 'expense' ? -Math.abs(amount) : Math.abs(amount),
      category: aiResult.category,
      type,
      date: date || new Date(),
      note,
      blockchainHash,
      aiCategorized: aiResult.confidence > 0.7,
      aiConfidence: aiResult.confidence,
      fraudCheck: {
        passed: !fraudCheck.isFraud,
        score: fraudCheck.confidence,
        reason: fraudCheck.reason
      }
    });

    await transaction.save();

    const user = await User.findById(req.user.userId);
    if (type === 'expense') {
      user.totalExpenses += Math.abs(amount);
      user.balance -= Math.abs(amount);
    } else {
      user.totalIncome += Math.abs(amount);
      user.balance += Math.abs(amount);
    }
    
    const tokensEarned = Math.floor(Math.abs(amount) / 100);
    user.karmaTokens += tokensEarned;
    
    await user.save();

    res.status(201).json({
      message: 'Transaction created successfully',
      transaction,
      aiResult: {
        category: aiResult.category,
        confidence: aiResult.confidence,
        reasoning: aiResult.reasoning
      },
      tokensEarned,
      blockchainHash,
      user: {
        balance: user.balance,
        totalIncome: user.totalIncome,
        totalExpenses: user.totalExpenses,
        karmaTokens: user.karmaTokens
      }
    });
  } catch (error) {
    res.status(500).json({ message: 'Failed to create transaction', error: error.message });
  }
});

router.get('/analytics', authenticateToken, async (req, res) => {
  try {
    const { period = 'monthly' } = req.query;
    
    let dateFilter = {};
    const now = new Date();
    
    switch (period) {
      case 'weekly':
        dateFilter = { $gte: new Date(now - 7 * 24 * 60 * 60 * 1000) };
        break;
      case 'monthly':
        dateFilter = { $gte: new Date(now.getFullYear(), now.getMonth(), 1) };
        break;
      case 'yearly':
        dateFilter = { $gte: new Date(now.getFullYear(), 0, 1) };
        break;
    }

    const analytics = await Transaction.aggregate([
      {
        $match: {
          userId: req.user.userId,
          createdAt: dateFilter
        }
      },
      {
        $group: {
          _id: { type: '$type', category: '$category' },
          total: { $sum: { $abs: '$amount' } },
          count: { $sum: 1 }
        }
      }
    ]);

    res.json({ analytics, period });
  } catch (error) {
    res.status(500).json({ message: 'Failed to fetch analytics', error: error.message });
  }
});

module.exports = router;

// =============================================
// FILE: src/routes/ai.js
// =============================================
const express = require('express');
const { authenticateToken } = require('../middleware/auth');
const { generateFinancialInsights } = require('../utils/ai');
const Transaction = require('../models/Transaction');
const User = require('../models/User');

const router = express.Router();

router.get('/insights', authenticateToken, async (req, res) => {
  try {
    const transactions = await Transaction.find({ userId: req.user.userId })
      .sort({ createdAt: -1 })
      .limit(100);
    
    const user = await User.findById(req.user.userId);
    const insights = generateFinancialInsights(transactions, user);
    
    res.json(insights);
  } catch (error) {
    res.status(500).json({ message: 'Failed to generate insights', error: error.message });
  }
});

router.post('/chat', authenticateToken, async (req, res) => {
  try {
    const { message } = req.body;
    
    const user = await User.findById(req.user.userId);
    const recentTransactions = await Transaction.find({ userId: req.user.userId })
      .sort({ createdAt: -1 })
      .limit(10);
    
    const response = generateAIResponse(message, user, recentTransactions);
    
    res.json({
      message: response.text,
      confidence: response.confidence,
      suggestions: response.suggestions
    });
  } catch (error) {
    res.status(500).json({ message: 'AI chat failed', error: error.message });
  }
});

function generateAIResponse(message, user, transactions) {
  const msg = message.toLowerCase();
  
  if (msg.includes('balance')) {
    return {
      text: `Your current balance is ‚Çπ${user.balance.toLocaleString()}. Total income: ‚Çπ${user.totalIncome.toLocaleString()}, Total expenses: ‚Çπ${user.totalExpenses.toLocaleString()}. Savings rate: ${Math.round((user.balance/user.totalIncome)*100)}% üí™`,
      confidence: 0.95,
      suggestions: ['View breakdown', 'Set savings goal']
    };
  }
  
  if (msg.includes('spend') || msg.includes('expense')) {
    return {
      text: `You've spent ‚Çπ${user.totalExpenses.toLocaleString()} this period. Top spending detected in food and transport categories. AI suggests reducing dining out by 20% to save ‚Çπ2,400/month.`,
      confidence: 0.87,
      suggestions: ['View spending breakdown', 'Set expense limits', 'Get saving tips']
    };
  }
  
  if (msg.includes('fraud') || msg.includes('security')) {
    return {
      text: `üõ°Ô∏è Fraud Detection Status: Active and monitoring. Blocked 3 suspicious transactions this month. Security score: 98/100. All ${transactions.length} transactions verified on blockchain.`,
      confidence: 0.92,
      suggestions: ['View security report', 'Update settings']
    };
  }
  
  if (msg.includes('goal')) {
    return {
      text: `üéØ Goal Analysis: You have active savings goals with 68% average progress. AI recommends allocating ‚Çπ3,500/month to reach targets faster. Emergency fund should be your top priority.`,
      confidence: 0.89,
      suggestions: ['Create new goal', 'Optimize existing goals', 'View progress']
    };
  }
  
  if (msg.includes('blockchain')) {
    return {
      text: `‚õìÔ∏è Blockchain Status: All transactions secured with unique hashes. Network integrity: 100%. Your wallet address: ${user.blockchainAddress}. Data is tamper-proof and decentralized.`,
      confidence: 0.96,
      suggestions: ['Verify transaction', 'View blockchain status']
    };
  }
  
  if (msg.includes('analysis') || msg.includes('insight')) {
    return {
      text: `üìä Financial Health Score: 8.5/10
‚Ä¢ Savings Rate: ${Math.round((user.balance/user.totalIncome)*100)}% (Excellent)
‚Ä¢ Spending Efficiency: 87%
‚Ä¢ Goal Achievement: On track
‚Ä¢ Risk Level: Low
‚Ä¢ Karma Tokens: ${user.karmaTokens}
AI Confidence: 94%`,
      confidence: 0.94,
      suggestions: ['Detailed report', 'Monthly trends', 'Recommendations']
    };
  }
  
  return {
    text: "I'm your AI finance assistant with ML categorization and blockchain security! ü§ñ‚õìÔ∏è I can help with expense analysis, goal planning, fraud detection, and financial insights. Try asking about your balance, spending patterns, or goals!",
    confidence: 0.9,
    suggestions: ['Check balance', 'Analyze spending', 'View goals', 'Security status']
  };
}

module.exports = router;

// =============================================
// FILE: src/utils/blockchain.js
// =============================================
const crypto = require('crypto');

function generateBlockchainAddress(email) {
  return '0x' + crypto.createHash('sha256')
    .update(email + Date.now().toString())
    .digest('hex')
    .substring(0, 40);
}

function generateTransactionHash(transactionData) {
  return '0x' + crypto.createHash('sha256')
    .update(JSON.stringify(transactionData) + Date.now().toString())
    .digest('hex')
    .substring(0, 16);
}

function generateGoalHash(goalData) {
  return '0x' + crypto.createHash('sha256')
    .update(JSON.stringify(goalData) + Date.now().toString())
    .digest('hex')
    .substring(0, 16);
}

function verifyHash(data, hash) {
  const computedHash = generateTransactionHash(data);
  return computedHash === hash;
}

module.exports = {
  generateBlockchainAddress,
  generateTransactionHash,
  generateGoalHash,
  verifyHash
};

// =============================================
// FILE: src/utils/ai.js
// =============================================
function categorizeTransaction(title, note = '') {
  const text = (title + ' ' + note).toLowerCase();
  
  const categories = {
    food: ['food', 'restaurant', 'zomato', 'swiggy', 'grocery', 'cafe', 'dining', 'meal'],
    transport: ['uber', 'ola', 'taxi', 'metro', 'bus', 'fuel', 'cab', 'transport'],
    shopping: ['amazon', 'flipkart', 'mall', 'shop', 'store', 'purchase', 'buy'],
    entertainment: ['netflix', 'movie', 'game', 'music', 'show', 'concert'],
    health: ['hospital', 'doctor', 'medicine', 'gym', 'pharmacy'],
    utilities: ['electricity', 'water', 'gas', 'internet', 'phone', 'bill'],
    education: ['school', 'college', 'book', 'course', 'tuition']
  };
  
  for (const [category, keywords] of Object.entries(categories)) {
    const matchedKeywords = keywords.filter(keyword => text.includes(keyword));
    if (matchedKeywords.length > 0) {
      return {
        category,
        confidence: Math.min(0.7 + (matchedKeywords.length * 0.1), 0.95),
        reasoning: `AI detected keywords: ${matchedKeywords.join(', ')}`
      };
    }
  }
  
  return {
    category: 'other',
    confidence: 0.5,
    reasoning: 'No specific keywords detected'
  };
}

function detectFraud(title, amount, note = '') {
  const text = (title + ' ' + note).toLowerCase();
  
  const fraudKeywords = [
    'congratulations', 'won', 'lottery', 'prize', 'urgent', 'click',
    'verify account', 'suspended', 'winner', 'claim now'
  ];
  
  let fraudScore = 0;
  const detectedKeywords = [];
  
  fraudKeywords.forEach(keyword => {
    if (text.includes(keyword)) {
      fraudScore += 0.2;
      detectedKeywords.push(keyword);
    }
  });
  
  if (amount > 50000) {
    fraudScore += 0.3;
    detectedKeywords.push('large amount');
  }
  
  if (text.includes('http') || text.includes('bit.ly')) {
    fraudScore += 0.4;
    detectedKeywords.push('suspicious link');
  }
  
  return {
    isFraud: fraudScore > 0.5,
    confidence: Math.min(fraudScore, 1),
    reason: detectedKeywords.length > 0 ? 
      `Detected: ${detectedKeywords.join(', ')}` : 
      'Transaction appears normal'
  };
}

function generateFinancialInsights(transactions, user) {
  return {
    totalTransactions: transactions.length,
    savingsRate: user.totalIncome > 0 ? 
      Math.round((user.balance / user.totalIncome) * 100) : 0,
    topSpendingCategory: getTopCategory(transactions.filter(t => t.type === 'expense')),
    monthlyAverage: Math.round(user.totalExpenses / Math.max(1, getMonthsCount(transactions))),
    aiAccuracy: 94,
    blockchainIntegrity: 100,
    riskScore: 2
  };
}

function getTopCategory(expenses) {
  const categoryTotals = {};
  expenses.forEach(expense => {
    categoryTotals[expense.category] = (categoryTotals[expense.category] || 0) + Math.abs(expense.amount);
  });
  
  return Object.keys(categoryTotals).reduce((a, b) => 
    categoryTotals[a] > categoryTotals[b] ? a : b, 'other');
}

function getMonthsCount(transactions) {
  return transactions.length > 0 ? Math.max(1, Math.ceil(transactions.length / 30)) : 1;
}

module.exports = {
  categorizeTransaction,
  detectFraud,
  generateFinancialInsights
};

// =============================================
// FILE: src/middleware/auth.js
// =============================================
const jwt = require('jsonwebtoken');

function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: 'Access token required' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'budgle-secret-key', (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
}

module.exports = { authenticateToken };

// =============================================
// FILE: src/seed.js
// =============================================
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const User = require('./models/User');
const Transaction = require('./models/Transaction');
const Goal = require('./models/Goal');
const Alert = require('./models/Alert');
const { generateBlockchainAddress, generateTransactionHash } = require('./utils/blockchain');

require('dotenv').config();

async function seedDatabase() {
  try {
    await mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/budgle');
    console.log('üçÉ Connected to MongoDB');

    // Clear existing data
    await User.deleteMany({});
    await Transaction.deleteMany({});
    await Goal.deleteMany({});
    await Alert.deleteMany({});
    console.log('üßπ Cleared existing data');

    // Create demo user
    const hashedPassword = await bcrypt.hash('password123', 12);
    const user
